
boolean colliding(float x1, float y1, int w1, int h1, float x2, float y2, int w2, int h2) {
  return abs(x1 - x2) * 2 < w1 + w2 && abs(y1 - y2) * 2 < h1 + h2;
}

int[] curLevel = {0, 0};

PFont BIT;

PImage pf1, pf2, pf3, ps1, ps2, ps3, pn1, pn2, pn3, spike, spike_guy, bb1, bb2, cf, cl, cs, cr;

class Tile {
  PVector pos;
  int width;
  int height;
  public void draw() {
    noStroke();
    fill(0);
    rect(pos.x - width/2, pos.y - height/2, width, height);
  }
}

class Block extends Tile {
  public Block(int x, int y, int w, int h) {
    pos = new PVector(x, y);
    width = w;
    height = h;
  }
  public Block(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }
}

class Spikes extends Tile {
  public Spikes(int x, int y, int w, int h) {
    pos = new PVector(x, y);
    width = w;
    height = h;
  }
  public Spikes(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }
  public void draw() {
    imageMode(CENTER);
    image(spike, pos.x, pos.y-2.5, width, height+5);
  }
}

class Hole extends Tile {
  public Hole(int x, int y, int w, int h) {
    pos = new PVector(x, y);
    width = w;
    height = h;
  }
  public Hole(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }
  public void draw() {
    noStroke();
    fill(0);
    ellipse(pos.x, pos.y, width, height);
  }
}

ArrayList<Block> blocks = new ArrayList<Block>();
ArrayList<Spikes> spikes = new ArrayList<Spikes>();
ArrayList<Hole> holes = new ArrayList<Hole>();

class Enemy {
  PVector pos;
  float dmg;
  int width;
  int height;
}

class SpikeGuy extends Enemy {
  public SpikeGuy(int x, int y) {
    pos = new PVector(x, y);
  }
  public void draw(){
    image(spike_guy, pos.x, pos.y, 40, 40);
  }
}

class BloodyBanana extends Enemy {
  int imgTime = 20;
  int curImg = 1;
  int dir = 0;
  int dirTime = 10;
  boolean[] canDir = {true, true, true, true};
  public BloodyBanana(int x, int y){
    pos = new PVector(x, y);
    width = height = 120;
  }
  public void runCollisions() {
    for(Block that: blocks) {
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.x > that.pos.x) {
            canDir[2] = false;
          }else{
            canDir[2] = true;
          }
          if(pos.x < that.pos.x) {
            canDir[0] = false;
          }else{
            canDir[0] = true;
          }
        }
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.y > that.pos.y) {
            canDir[3] = false;
          }else{
            canDir[3] = true;
          }
          if(pos.y < that.pos.y) {
            canDir[1] = false;
          }else{
            canDir[1] = true;
          }
        }
      }
    }
  }
  public void draw() {
    if(imgTime > 0){
      imgTime--;
    }else if(curImg < 2){
      curImg++;
      imgTime = 20;
    }else{
      curImg = 1;
      imgTime = 20;
    }
    if(curImg == 1){
      image(bb1, pos.x, pos.y, width, height);
    }
    if(curImg == 2){
      image(bb2, pos.x, pos.y, width, height);
    }
  }
  public void update() {
    if(dirTime > 0){
      dirTime--;
    }else{
      dir = floor(random(0, 4));
      dirTime = 10;
    }
    if(dir == 0 && canDir[0] == true){
      pos.x -= 2;
    }
    if(dir == 1 && canDir[1] == true){
      pos.y -= 2;
    }
    if(dir == 2 && canDir[2] == true){
      pos.x += 2;
    }
    if(dir == 3 && canDir[3] == true){
      pos.y += 2;
    }
  }
}

ArrayList<SpikeGuy> spikeGuys = new ArrayList<SpikeGuy>();
ArrayList<BloodyBanana> bloodyBananas = new ArrayList<BloodyBanana>();

class Item {
  PVector pos;
  int width;
  int height;
}

class Coin extends Item {
  int cImg = 1;
  int cImgTime = 3;
  boolean isHit = false;
  public Coin(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }

  public void draw() {
    if(cImgTime > 0){
      cImgTime -= 1;
    }else if(cImg < 4){
      cImg += 1;
      cImgTime = 3;
    }else{
      cImg = 1;
      cImgTime = 3;
    }
    if(cImg == 1){
      image(cf, pos.x, pos.y, 40, 40);
    }
    if(cImg == 2){
      image(cl, pos.x, pos.y, 40, 40);
    }
    if(cImg == 3){
      image(cs, pos.x, pos.y, 40, 40);
    }
    if(cImg == 4){
      image(cr, pos.x, pos.y, 40, 40);
    }
  }
}

class HealthPack extends Item {}

ArrayList<Coin> coins = new ArrayList<Coin>();
ArrayList<HealthPack> healthPacks = new ArrayList<HealthPack>();

class Player {
  PVector pos;
  PVector vel;
  int img = 1;
  int imgCat = 1;
  int imgTime = 2;
  int width;
  int height;
  int health = 100;
  int hurtTimer = 0;
  int score = 0;
  public Player() {
    pos = new PVector(200, 200);
    vel = new PVector(0, 0);
    width = 40;
    height = 60;
  }
  public Player(int x, int y) {
    pos = new PVector(x, y);
    vel = new PVector(0, 0);
    width = 40;
    height = 60;
  }
  public void runCollisions() {
    for(Block that: blocks) {
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.x = 0;
          if(pos.x > that.pos.x) {
            pos.x = that.pos.x + width/2 + that.width/2;
          }
          if(pos.x < that.pos.x) {
            pos.x = that.pos.x - width/2 - that.width/2;
          }
        }
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.y = 0;
          if(pos.y > that.pos.y) {
            pos.y = that.pos.y + height/2 + that.height/2;
          }
          if(pos.y < that.pos.y) {
            pos.y = that.pos.y - height/2 - that.height/2;
          }
        }
      }
    }
    for(Hole that: holes) {
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.x = 0;
          if(pos.x > that.pos.x) {
            pos.x = that.pos.x + width/2 + that.width/2;
          }
          if(pos.x < that.pos.x) {
            pos.x = that.pos.x - width/2 - that.width/2;
          }
        }
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.y = 0;
          if(pos.y > that.pos.y) {
            pos.y = that.pos.y + height/2 + that.height/2;
          }
          if(pos.y < that.pos.y) {
            pos.y = that.pos.y - height/2 - that.height/2;
          }
        }
      }
    }
    for(Spikes that: spikes) {
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if (hurtTimer == 0) {
          health -= 15;
          hurtTimer = 100;
        }
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.x > that.pos.x) {
            vel.x = 9;
            pos.x = that.pos.x + width/2 + that.width/2;
          }
          if(pos.x < that.pos.x) {
            vel.x = -9;
            pos.x = that.pos.x - width/2 - that.width/2;
          }
        }
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.y > that.pos.y) {
            vel.y = 9;
            pos.y = that.pos.y + height/2 + that.height/2;
          }
          if(pos.y < that.pos.y) {
            vel.y = -9;
            pos.y = that.pos.y - height/2 - that.height/2;
          }
        }
      }
    }
    for(Coin that: coins){
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if(!that.isHit){
          score += 1;
        }
        that.isHit = true;
      }
    }
  }
  public void draw() {
    noStroke();
    fill(255, 0, 0, (hurtTimer%20 < 10) ? 255 : 100);
    imageMode(CORNER);
    if(img == 1 && imgCat == 1){
      image(pf1, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 2 && imgCat == 1){
      image(pf2, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 3 && imgCat == 1){
      image(pf3, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 1 && imgCat == 2){
      image(ps1, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 2 && imgCat == 2){
      image(ps2, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 3 && imgCat == 2){
      image(ps3, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 1 && imgCat == 3){
      pushMatrix();
      scale(-1, 1);
      translate(-pos.x*2, 0);
      image(ps1, pos.x - width/2, pos.y - height, width, height*1.5);
      popMatrix();
    }
    if(img == 2 && imgCat == 3){
      pushMatrix();
      scale(-1, 1);
      translate(-pos.x*2, 0);
      image(ps2, pos.x - width/2, pos.y - height, width, height*1.5);
      popMatrix();
    }
    if(img == 3 && imgCat == 3){
      pushMatrix();
      scale(-1, 1);
      translate(-pos.x*2, 0);
      image(ps3, pos.x - width/2, pos.y - height, width, height*1.5);
      popMatrix();
    }
    if(img == 1 && imgCat == 4){
      image(pn1, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 2 && imgCat == 4){
      image(pn2, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 3 && imgCat == 4){
      image(pn3, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    fill(214, 17, 17);
    rect(-285, -285, health, 15);
    fill(0);
    textSize(15);
    textFont(BIT, 15);
    text("SCORE: " + score, -120, -278);
  }
  public void update() {
    vel.mult(0.9);
    pos.add(vel);
    if(keyPressed&&keyCode==38) {
      vel.y -= 0.1;
      pos.y -= 4;
      imgCat = 4;
      if(imgTime > 0){
        imgTime--;
      }else if(img < 3){
        img++;
        imgTime = 2;
      }else{
        img = 1;
        imgTime = 2;
      }
    }else if(keyCode!=40){
      vel.y = 0;
    }
    if(keyPressed&&keyCode==37) {
      vel.x -= 0.1;
      pos.x -= 4;
      imgCat = 3;
      if(imgTime > 0){
        imgTime--;
      }else if(img < 3){
        img++;
        imgTime = 2;
      }else{
        img = 1;
        imgTime = 2;
      }
    }else if(keyCode!=39){
      vel.x = 0;
    }
    if(keyPressed&&keyCode==40) {
      vel.y += 0.2;
      pos.y += 4;
      imgCat = 1;
      if(imgTime > 0){
        imgTime--;
      }else if(img < 3){
        img++;
        imgTime = 2;
      }else{
        img = 1;
        imgTime = 2;
      }
    }else if(keyCode!=38){
      vel.y = 0;
    }
    if(keyPressed&&keyCode==39) {
      vel.x += 0.1;
      pos.x += 4;
      imgCat = 2;
      if(imgTime > 0){
        imgTime--;
      }else if(img < 3){
        img++;
        imgTime = 2;
      }else{
        img = 1;
        imgTime = 2;
      }
    }else if(keyCode!=37){
      vel.x = 0;
    }
    if (hurtTimer > 0) {
      hurtTimer--;
    }
    pos.set(constrain(pos.x, -300 + width/2, 300 - width/2), constrain(pos.y, -300 + height/2, 300 - height/2));
  }
  public void display() {
    runCollisions();
    update();
    draw();
  }
}

Player player;

int[][][][] levels = {
  {
    {
      {5,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,1,0,0,0,0,0,0},
      {0,0,0,0,0,0,1,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,2,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,2,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,1,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,0,1,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,1,1,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,6,0,0,0,0,0,6},
    },
    {
      {5,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,1,1,1,2,0,0,0,0,0,0,0},
      {0,0,0,0,1,0,0,1,0,0,0,0,0,0,0},
      {0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,2,1,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,6,0,0,0,0,0,6},
    }
  }
};

void buildLevel(int level) {
  int lvl = floor(random(levels[level].length));
  for(int y = 0;y < levels[level][lvl].length;y++) {
    for(int x = 0;x < levels[level][lvl][y].length;x++) {
      switch(levels[level][lvl][y][x]) {
        case 1: blocks.add(new Block(x * 40 - 280, y * 40 - 280)); break;
        case 2: spikes.add(new Spikes(x * 40 - 280, y * 40 - 280)); break;
        case 3: holes.add(new Hole(x * 40 - 280, y * 40 - 280)); break;
        case 4: spikeGuys.add(new SpikeGuy(x * 40 - 280, y * 40 - 280)); break;
        case 5: bloodyBananas.add(new BloodyBanana(x * 40 - 280, y * 40 - 280)); break;
        case 6: coins.add(new Coin(x * 40 - 280, y * 40 - 280)); break;
      }
    }
  }
}

void setup() {
  fullScreen();
  player = new Player(-200, -200);

  BIT = createFont("PressStart2P-Regular.ttf", 25);

  //There is no real efficient way to load images. :( ;_;

  pf1 = loadImage("f1.png");
  pf2 = loadImage("f2.png");
  pf3 = loadImage("f3.png");
  ps1 = loadImage("l1.png");
  ps2 = loadImage("l2.png");
  ps3 = loadImage("l3.png");
  pn1 = loadImage("n1.png");
  pn2 = loadImage("n2.png");
  pn3 = loadImage("n3.png");

  spike = loadImage("spike.png");
  cf = loadImage("coin_f.png");
  cl = loadImage("coin_l.png");
  cr = loadImage("coin_r.png");
  cs = loadImage("coin_s.png");

  spike_guy = loadImage("spike_guy.png");
  bb1 = loadImage("bb1.png");
  bb2 = loadImage("bb2.png");

  buildLevel(0);
  noSmooth();
}

void draw() {
  background(0);
  pushMatrix();
  translate(width/2, height/2);
  scale(0.1);
  scale(0.1);
  int s = min(width/8, height/6);
  scale(s);
  fill(255);
  noStroke();
  rect(-300, -300, 600, 600);
  for(Block that: blocks) {
    that.draw();
  }
  for(Spikes that: spikes) {
    that.draw();
  }
  for(Hole that: holes) {
    that.draw();
  }
  for(SpikeGuy that: spikeGuys){
    that.draw();
  }
  for(BloodyBanana that: bloodyBananas){
    that.draw();
    that.runCollisions();
    that.update();
  }
  for(Coin that: coins){
    if(!that.isHit){
      that.draw();
    }
  }
  player.display();
  if(player.health <= 0){
    background(255, 0, 0);
    fill(0);
    textSize(75);
    text("YOU DIED", 0, -200);
    textSize(20);
    text("YOUR FINAL SCORE WAS: " + player.score, 0, 0);
    textSize(15);
    text("PRESS ESCAPE", 0, 200);
    noLoop();
  }
  popMatrix();

  fill(0, 0, 0, 100);
  rectMode(CENTER);
  rect(width/2, 50, 100, 50);
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(10);
  text("Press esc\nto quit", width/2, 50);
  rectMode(CORNER);

}
