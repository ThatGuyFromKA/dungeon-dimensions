
// Import sounds and create sound variables(SoundFiles)
import processing.sound.*;
SoundFile coinSound, spikeSound, dieSound, walkSound;

// A function for collision
boolean colliding(float x1, float y1, int w1, int h1, float x2, float y2, int w2, int h2) {
  return abs(x1 - x2) * 2 < w1 + w2 && abs(y1 - y2) * 2 < h1 + h2;
}

// The array that stores the current "room"
int[] curLevel = {0, 0};

// Creates a ProcessingFont so that the font can be used in the game.
PFont BIT;

// Creates a lot of ProcessingImages so that images can be displayed in the game.
PImage pf1, pf2, pf3, ps1, ps2, ps3, pn1, pn2, pn3, spike, spike_guy, bb1, bb2, cf, cl, cs, cr;

// Creates a class ("Tile") to use as the basis for all the tiles in the game.
class Tile {
  PVector pos;
  int width;
  int height;
  public void draw() {
    noStroke();
    fill(0);
    rect(pos.x - width/2, pos.y - height/2, width, height);
  }
}

// A "Block" class. An extension of the Tile class.
class Block extends Tile {
  public Block(int x, int y, int w, int h) {
    pos = new PVector(x, y);
    width = w;
    height = h;
  }
  public Block(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }
}

// A "Spikes" class. Another extension of the Tile class.
class Spikes extends Tile {
  public Spikes(int x, int y, int w, int h) {
    pos = new PVector(x, y);
    width = w;
    height = h;
  }
  public Spikes(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }
  public void draw() {
    imageMode(CENTER);
    image(spike, pos.x, pos.y-2.5, width, height+5);
  }
}

// A "Hole" class. Also an extension of the Tile class.
class Hole extends Tile {
  public Hole(int x, int y, int w, int h) {
    pos = new PVector(x, y);
    width = w;
    height = h;
  }
  public Hole(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }
  public void draw() {
    noStroke();
    fill(0);
    ellipse(pos.x, pos.y, width, height);
  }
}

// Arrays to hold all the "Tile"s in the game.
ArrayList<Block> blocks = new ArrayList<Block>();
ArrayList<Spikes> spikes = new ArrayList<Spikes>();
ArrayList<Hole> holes = new ArrayList<Hole>();

// A base "Enemy" class.
class Enemy {
  PVector pos;
  float dmg;
  int width;
  int height;
}

// A "SpikeGuy" extension of the Enemy class.
// The Spike Guy is a floating spike that flies around randomly
class SpikeGuy extends Enemy {
  public SpikeGuy(int x, int y) {
    pos = new PVector(x, y);
  }
  public void draw(){
    image(spike_guy, pos.x, pos.y, 40, 40);
  }
}

// A "BloodyBanana" extension of the Enemy class.
// The Bloody Banana is a roughly tiger-like monster that roams around randomly, attacking you when near.
class BloodyBanana extends Enemy {
  int imgTime = 20;
  int curImg = 1;
  int dir = 0;
  int dirTime = 10;
  boolean[] canDir = {true, true, true, true};
  public BloodyBanana(int x, int y){
    pos = new PVector(x, y);
    width = height = 120;
  }
  public void runCollisions() {
    for(Block that: blocks) {
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.x > that.pos.x) {
            canDir[2] = false;
          }else{
            canDir[2] = true;
          }
          if(pos.x < that.pos.x) {
            canDir[0] = false;
          }else{
            canDir[0] = true;
          }
        }
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.y > that.pos.y) {
            canDir[3] = false;
          }else{
            canDir[3] = true;
          }
          if(pos.y < that.pos.y) {
            canDir[1] = false;
          }else{
            canDir[1] = true;
          }
        }
      }
    }
  }
  public void draw() {
    if(imgTime > 0){
      imgTime--;
    }else if(curImg < 2){
      curImg++;
      imgTime = 20;
    }else{
      curImg = 1;
      imgTime = 20;
    }
    if(curImg == 1){
      image(bb1, pos.x, pos.y, width, height);
    }
    if(curImg == 2){
      image(bb2, pos.x, pos.y, width, height);
    }
  }
  public void update() {
    if(dirTime > 0){
      dirTime--;
    }else{
      dir = floor(random(0, 4));
      dirTime = 10;
    }
    if(dir == 0 && canDir[0] == true){
      pos.x -= 2;
    }
    if(dir == 1 && canDir[1] == true){
      pos.y -= 2;
    }
    if(dir == 2 && canDir[2] == true){
      pos.x += 2;
    }
    if(dir == 3 && canDir[3] == true){
      pos.y += 2;
    }
  }
}

// Arrays to hold all the "Enemy"s in the game.
ArrayList<SpikeGuy> spikeGuys = new ArrayList<SpikeGuy>();
ArrayList<BloodyBanana> bloodyBananas = new ArrayList<BloodyBanana>();

// A base "Item" class.
class Item {
  PVector pos;
  int width;
  int height;
}

// A "Coin" "Item".
class Coin extends Item {
  int cImg = 1;
  int cImgTime = 3;
  boolean isHit = false;
  public Coin(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }

  public void draw() {
    if(cImgTime > 0){
      cImgTime -= 1;
    }else if(cImg < 4){
      cImg += 1;
      cImgTime = 3;
    }else{
      cImg = 1;
      cImgTime = 3;
    }
    if(cImg == 1){
      image(cf, pos.x, pos.y, 40, 40);
    }
    if(cImg == 2){
      image(cl, pos.x, pos.y, 40, 40);
    }
    if(cImg == 3){
      image(cs, pos.x, pos.y, 40, 40);
    }
    if(cImg == 4){
      image(cr, pos.x, pos.y, 40, 40);
    }
  }
}

// A "HealthPack" "Item". For refilling player health.
class HealthPack extends Item {}

// Arrays to hold all the "Item"s in the game.
ArrayList<Coin> coins = new ArrayList<Coin>();
ArrayList<HealthPack> healthPacks = new ArrayList<HealthPack>();

// The "Player" class. Be warned, it's quite large.
class Player {

  PVector pos;// Player x and y
  PVector vel;// Player x and y movement velocity
  int img = 1;// The current player image displayed
  int imgCat = 1;// The current player image category displayed
  int imgTime = 2;// The time between image switching
  int width;// The width of the player
  int height;// The height of the player
  int health = 100;// The players health or HP.
  int hurtTimer = 0;// The timer that tells the program when the player can be invulnerable.
  int score = 0;// The player's score.(Coins)

  // Sets objects of the player's variables.
  public Player() {
    pos = new PVector(200, 200);
    vel = new PVector(0, 0);
    width = 40;
    height = 60;
  }
  public Player(int x, int y) {
    pos = new PVector(x, y);
    vel = new PVector(0, 0);
    width = 40;
    height = 60;
  }

  // Collisions between the player and other items.
  public void runCollisions() {

    // Player/Block collisions.
    for(Block that: blocks) {
      // If the player is hitting the block
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        // And the player is hitting one of the sides
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.x = 0;// Set the x velocity of the player to 0.
          if(pos.x > that.pos.x) {// If the player x is greater than the block x.
            pos.x = that.pos.x + width/2 + that.width/2;// Stop the player.
          }
          if(pos.x < that.pos.x) {// If the player x is less than the block x.
            pos.x = that.pos.x - width/2 - that.width/2;// Stop the player.
          }
        }
        // (Or) And the player is hitting the top or bottom
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.y = 0;// Set the player y velocity to 0.
          if(pos.y > that.pos.y) {// If the player y is greater than the block y.
            pos.y = that.pos.y + height/2 + that.height/2;// Stop the player.
          }
          if(pos.y < that.pos.y) {// If the player y is less than the block y.
            pos.y = that.pos.y - height/2 - that.height/2;// Stop the player.
          }
        }
      }
    }

    // Player/Hole collisions.
    for(Hole that: holes) {
      // If the player and the hole are colliding.
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        // And the player is hitting the sides of the hole.
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.x = 0;// set the player's x velocity to 0.
          if(pos.x > that.pos.x) {// If the player x is greater than the hole x.
            pos.x = that.pos.x + width/2 + that.width/2;// Stop the player.
          }
          if(pos.x < that.pos.x) {// If the player x is less than the hole x.
            pos.x = that.pos.x - width/2 - that.width/2;// Stop the player.
          }
        }
        // (Or) And the player is hitting the top or bottom of the hole.
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.y = 0;// set the player y velocity to 0.
          if(pos.y > that.pos.y) {// If the player y is greater than the hole y.
            pos.y = that.pos.y + height/2 + that.height/2;// Stop the player.
          }
          if(pos.y < that.pos.y) {// If the player y is less than the hole y.
            pos.y = that.pos.y - height/2 - that.height/2;// Stop the player.
          }
        }
      }
    }

    // Player/Spike collisions.
    for(Spikes that: spikes) {
      // If the player is touching the spike.
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if (hurtTimer == 0) {// And the player hasn't been hurt within the last 100 frames.
          health -= 15;// take away some health from the player
          hurtTimer = 100;// and tell the program that the player was just hurt.
          spikeSound.play();// As well as playing the sound that plays when a player hits the spike.
        }
        // Same as block and hole. Difference is that velocity is set to 9 instead.
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.x > that.pos.x) {
            vel.x = 9;
            pos.x = that.pos.x + width/2 + that.width/2;
          }
          if(pos.x < that.pos.x) {
            vel.x = -9;
            pos.x = that.pos.x - width/2 - that.width/2;
          }
        }
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.y > that.pos.y) {
            vel.y = 9;
            pos.y = that.pos.y + height/2 + that.height/2;
          }
          if(pos.y < that.pos.y) {
            vel.y = -9;
            pos.y = that.pos.y - height/2 - that.height/2;
          }
        }
      }
    }

    // Player/Coin collisions.
    for(Coin that: coins){
      // If the player is colliding with the coin.
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if(!that.isHit){// And the coin hasn't been collected yet. :P
          score += 1;// Increment the player's score
          coinSound.play();// And play a coin sound.
        }
        that.isHit = true;// Tell the program the coin has been collected.
      }
    }
  }

  // Draw the player.
  public void draw() {
    noStroke();
    // fill(255, 255, 255, (hurtTimer%20 < 10) ? 255 : 100);// Player color.
    imageMode(CORNER);
    if(img == 1 && imgCat == 1){
      image(pf1, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 2 && imgCat == 1){
      image(pf2, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 3 && imgCat == 1){
      image(pf3, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 1 && imgCat == 2){
      image(ps1, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 2 && imgCat == 2){
      image(ps2, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 3 && imgCat == 2){
      image(ps3, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 1 && imgCat == 3){
      pushMatrix();
      scale(-1, 1);
      translate(-pos.x*2, 0);
      image(ps1, pos.x - width/2, pos.y - height, width, height*1.5);
      popMatrix();
    }
    if(img == 2 && imgCat == 3){
      pushMatrix();
      scale(-1, 1);
      translate(-pos.x*2, 0);
      image(ps2, pos.x - width/2, pos.y - height, width, height*1.5);
      popMatrix();
    }
    if(img == 3 && imgCat == 3){
      pushMatrix();
      scale(-1, 1);
      translate(-pos.x*2, 0);
      image(ps3, pos.x - width/2, pos.y - height, width, height*1.5);
      popMatrix();
    }
    if(img == 1 && imgCat == 4){
      image(pn1, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 2 && imgCat == 4){
      image(pn2, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    if(img == 3 && imgCat == 4){
      image(pn3, pos.x - width/2, pos.y - height, width, height*1.5);
    }
    // rect(pos.x - width/2, pos.y - height, width, height*1.5);
    // if(hurtTimer > 0){
    //   for(int i = 0; i < pf1.width; i++){
    //     for(int j = 0; j < pf1.height; j++){
    //       pf1.set(i, j, color(255, 0, 0));
    //     }
    //   }
    // }
    //fill(255, 255, 255, hurtTimer);
    //pf1.mask(rect(pos.x, pos.y, width, height));
    fill(214, 17, 17);
    rect(-285, -285, health, 15);
    fill(0);
    textSize(15);
    textFont(BIT, 15);
    text("SCORE: " + score, -120, -278);
  }
  public void update() {
    vel.mult(0.9);
    pos.add(vel);
    if(keyPressed&&keyCode==38) {
      // walkSound.loop(0.25);
      vel.y -= 0.1;
      pos.y -= 4;
      imgCat = 4;
      if(imgTime > 0){
        imgTime--;
      }else if(img < 3){
        img++;
        imgTime = 2;
      }else{
        img = 1;
        imgTime = 2;
      }
    }else if(keyCode!=40){
      vel.y = 0;
    }
    if(keyPressed&&keyCode==37) {
      // walkSound.loop(0.25);
      vel.x -= 0.1;
      pos.x -= 4;
      imgCat = 3;
      if(imgTime > 0){
        imgTime--;
      }else if(img < 3){
        img++;
        imgTime = 2;
      }else{
        img = 1;
        imgTime = 2;
      }
    }else if(keyCode!=39){
      vel.x = 0;
    }
    if(keyPressed&&keyCode==40) {
      // walkSound.loop(0.25);
      vel.y += 0.2;
      pos.y += 4;
      imgCat = 1;
      if(imgTime > 0){
        imgTime--;
      }else if(img < 3){
        img++;
        imgTime = 2;
      }else{
        img = 1;
        imgTime = 2;
      }
    }else if(keyCode!=38){
      vel.y = 0;
    }
    if(keyPressed&&keyCode==39) {
      // walkSound.loop(0.25);
      vel.x += 0.1;
      pos.x += 4;
      imgCat = 2;
      if(imgTime > 0){
        imgTime--;
      }else if(img < 3){
        img++;
        imgTime = 2;
      }else{
        img = 1;
        imgTime = 2;
      }
    }else if(keyCode!=37){
      vel.x = 0;
    }
    if (hurtTimer > 0) {
      hurtTimer--;
    }
    pos.set(constrain(pos.x, -300 + width/2, 300 - width/2), constrain(pos.y, -300 + height/2, 300 - height/2));
  }
  public void display() {
    runCollisions();
    update();
    draw();
  }
}

// An object of the "Player" class.
Player player;

// A 4D arrray of levels.
int[][][][] levels = {
  {
    {
      {5,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,1,0,0,0,0,0,0},
      {0,0,0,0,0,0,1,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,2,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,2,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,1,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,0,1,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,1,1,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,6,0,0,0,0,0,6},
    },
    {
      {5,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,1,1,1,2,0,0,0,0,0,0,0},
      {0,0,0,0,1,0,0,1,0,0,0,0,0,0,0},
      {0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,2,1,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,6,0,0,0,0,0,6},
    }
  }
};

// A function that reads the 4D array and translates it into objects.
void buildLevel(int level) {
  int lvl = floor(random(levels[level].length));
  for(int y = 0;y < levels[level][lvl].length;y++) {
    for(int x = 0;x < levels[level][lvl][y].length;x++) {
      switch(levels[level][lvl][y][x]) {
        case 1: blocks.add(new Block(x * 40 - 280, y * 40 - 280)); break;
        case 2: spikes.add(new Spikes(x * 40 - 280, y * 40 - 280)); break;
        case 3: holes.add(new Hole(x * 40 - 280, y * 40 - 280)); break;
        case 4: spikeGuys.add(new SpikeGuy(x * 40 - 280, y * 40 - 280)); break;
        case 5: bloodyBananas.add(new BloodyBanana(x * 40 - 280, y * 40 - 280)); break;
        case 6: coins.add(new Coin(x * 40 - 280, y * 40 - 280)); break;
      }
    }
  }
}

// The setup function.
void setup() {
  // Makes the game full screen.
  fullScreen();
  // sets the player location.
  player = new Player(-200, -200);

  // The sounds.
  coinSound = new SoundFile(this, "coin.wav");
  spikeSound = new SoundFile(this, "metal-small3.wav");
  dieSound = new SoundFile(this, "spell.wav");
  walkSound = new SoundFile(this, "cloth.wav");

  // The font.
  BIT = createFont("PressStart2P-Regular.ttf", 25);

  // The player images.
  pf1 = loadImage("f1.png");
  pf2 = loadImage("f2.png");
  pf3 = loadImage("f3.png");
  ps1 = loadImage("l1.png");
  ps2 = loadImage("l2.png");
  ps3 = loadImage("l3.png");
  pn1 = loadImage("n1.png");
  pn2 = loadImage("n2.png");
  pn3 = loadImage("n3.png");

  // The item/tile images.
  spike = loadImage("spike.png");
  cf = loadImage("coin_f.png");
  cl = loadImage("coin_l.png");
  cr = loadImage("coin_r.png");
  cs = loadImage("coin_s.png");

  // The enemy images.
  spike_guy = loadImage("spike_guy.png");
  bb1 = loadImage("bb1.png");
  bb2 = loadImage("bb2.png");

  // Reads a level
  buildLevel(0);
  // Makes the images look good.
  noSmooth();
}

// The draw function. For animation.
void draw() {

  // A black background for the game.
  background(0);

  //Scaling
  pushMatrix();
  translate(width/2, height/2);// Centers the screen
  scale(0.1);// shrinks the screen to 1/10 of the size.
  scale(0.1);// shrinks the screen to 1/10 again (even smaller).
  int s = min(width/8, height/6);// creates a variable that sets the final size of the screen.
  scale(s);// implements the variable that sets the final size of the screen. (screen is now fullscreen).

  fill(255);//White Background Color
  noStroke();//Gets rid of ugly lines.
  rect(-300, -300, 600, 600);// White Background

  // Draws block objects.
  for(Block that: blocks) {
    that.draw();
  }

  // Draws spike objects.
  for(Spikes that: spikes) {
    that.draw();
  }

  // Draws hole objects.
  for(Hole that: holes) {
    that.draw();
  }

  // Draws Spike Guy objects.
  for(SpikeGuy that: spikeGuys){
    that.draw();
  }

  // Draws and runs Bloody Banana objects.
  for(BloodyBanana that: bloodyBananas){
    that.draw();
    that.runCollisions();
    that.update();
  }

  // Draws Coin objects (if they haven't been collected yet).
  for(Coin that: coins){
    if(!that.isHit){
      that.draw();
    }
  }

  // Draws the player.
  player.display();

  popMatrix();

  // "Press esc to quit" box.
  fill(0, 0, 0, 100);
  rectMode(CENTER);
  rect(width/2, 50, 100, 50);
  fill(255);
  textAlign(CENTER, CENTER);
  textSize(10);
  text("Press esc\nto quit", width/2, 50);
  rectMode(CORNER);

  fill(255);
  textSize(75);
  textAlign(CENTER, CENTER);
  textLeading(90);
  text("D\nU\nN\nG\nE\nO\nN", 125, height/2);
  // textLeading(10*8);
  text("D\nI\nM\nE\nN\nS\nI\nO\nN\nS", width-125, height/2);

  pushMatrix();
  translate(width/2, height/2);// Centers the screen
  scale(0.1);// shrinks the screen to 1/10 of the size.
  scale(0.1);// shrinks the screen to 1/10 again (even smaller).
  // int s = min(width/8, height/6);// creates a variable that sets the final size of the screen.
  scale(s);// implements the variable that sets the final size of the screen. (screen is now fullscreen).

  // Game over screen
  if(player.health <= 0){
    dieSound.play();
    background(255, 0, 0);
    fill(0);
    textSize(75);
    text("YOU DIED", 0, -200);
    textSize(20);
    text("YOUR FINAL SCORE WAS: " + player.score, 0, 0);
    textSize(15);
    text("PRESS ESCAPE", 0, 200);
    noLoop();
  }

  popMatrix();// For the scaling?
}
