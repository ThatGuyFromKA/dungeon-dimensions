HashMap<Integer, Boolean> keys = new HashMap<Integer, Boolean>();

void keyPressed () {
  keys.put(keyCode, true);
}
void keyReleased() {
  keys.put(keyCode, false);
}

boolean colliding(float x1, float y1, int w1, int h1, float x2, float y2, int w2, int h2) {
  return abs(x1 - x2) * 2 < w1 + w2 && abs(y1 - y2) * 2 < h1 + h2;
}

PImage pf1, pf2, pf3, ps1, ps2, ps3, pn1, pn2, pn3, spike, spike_guy, bb1, bb2, bb3, bb4;

class Tile {
  PVector pos;
  int width;
  int height;
  public void draw() {
    noStroke();
    fill(0);
    rect(pos.x - width/2, pos.y - height/2, width, height);
  }
}

class Block extends Tile {
  public Block(int x, int y, int w, int h) {
    pos = new PVector(x, y);
    width = w;
    height = h;
  }
  public Block(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }
}

class Spikes extends Tile {
  public Spikes(int x, int y, int w, int h) {
    pos = new PVector(x, y);
    width = w;
    height = h;
  }
  public Spikes(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }
  public void draw() {
    imageMode(CENTER);
    image(spike, pos.x, pos.y-2.5, width, height+5);
  }
}

class Hole extends Tile {
  public Hole(int x, int y, int w, int h) {
    pos = new PVector(x, y);
    width = w;
    height = h;
  }
  public Hole(int x, int y) {
    pos = new PVector(x, y);
    width = height = 40;
  }
  public void draw() {
    noStroke();
    fill(0);
    ellipse(pos.x, pos.y, width, height);
  }
}

ArrayList<Block> blocks = new ArrayList<Block>();
ArrayList<Spikes> spikes = new ArrayList<Spikes>();
ArrayList<Hole> holes = new ArrayList<Hole>();

class Enemy {
  PVector pos;
  float dmg;
}

class SpikeGuy extends Enemy {
  public SpikeGuy(int x, int y, int spd) {
    pos = new PVector(x, y);
    image(spikeGuy, pos.x, pos.y, 40, 40);
  }
  public SpikeGuy(int x, int y, int spd){
    pos = new PVector(x, y);
    image(spikeGuy, pos.x, pos.y, 40, 40);
  }
  public SpikeGuy(int x, int y){
    pos = new PVector(x, y);
    image(spikeGuy, pos.x, pos.y, 40, 40);
  }
  public SpikeGuy(int x, int y){
    pos = new PVector(x, y);
    spd = 1;
    image(spikeGuy, pos.x, pos.y, 40, 40);
  }
}

class BloodyBanana extends Enemy {
  public BloodyBananaa(int x, int y, int spd){
    pos = new PVector(x, y);
    image(bb1, pos.x, pos.y, 50, 50);
  }
}

ArrayList<SpikeGuy> spikeGuys = new ArrayList<SpikeGuy>();
ArrayList<BloodyBanana> bloodyBananas = new ArrayList<BloodyBanana>();

class Player{
  PVector pos;
  PVector vel;
  int width;
  int height;
  int health = 100;
  int hurtTimer = 0;
  public Player() {
    pos = new PVector(200, 200);
    vel = new PVector(0, 0);
    width = height = 40;
  }
  public Player(int x, int y) {
    pos = new PVector(x, y);
    vel = new PVector(0, 0);
    width = height = 40;
  }
  public void runCollisions() {
    for(Block that: blocks) {
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.x = 0;
          if(pos.x > that.pos.x) {
            pos.x = that.pos.x + width/2 + that.width/2;
          }
          if(pos.x < that.pos.x) {
            pos.x = that.pos.x - width/2 - that.width/2;
          }
        }
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.y = 0;
          if(pos.y > that.pos.y) {
            pos.y = that.pos.y + height/2 + that.height/2;
          }
          if(pos.y < that.pos.y) {
            pos.y = that.pos.y - height/2 - that.height/2;
          }
        }
      }
    }
    for(Hole that: holes) {
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.x = 0;
          if(pos.x > that.pos.x) {
            pos.x = that.pos.x + width/2 + that.width/2;
          }
          if(pos.x < that.pos.x) {
            pos.x = that.pos.x - width/2 - that.width/2;
          }
        }
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          vel.y = 0;
          if(pos.y > that.pos.y) {
            pos.y = that.pos.y + height/2 + that.height/2;
          }
          if(pos.y < that.pos.y) {
            pos.y = that.pos.y - height/2 - that.height/2;
          }
        }
      }
    }
    for(Spikes that: spikes) {
      if(colliding(pos.x, pos.y, width, height, that.pos.x, that.pos.y, that.width, that.height)) {
        if (hurtTimer == 0) {
          health -= 15;
          hurtTimer = 100;
        }
        if(abs(pos.x - that.pos.x)/(width + that.width) > abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.x > that.pos.x) {
            vel.x = 9;
            pos.x = that.pos.x + width/2 + that.width/2;
          }
          if(pos.x < that.pos.x) {
            vel.x = -9;
            pos.x = that.pos.x - width/2 - that.width/2;
          }
        }
        else if(abs(pos.x - that.pos.x)/(width + that.width) < abs(pos.y - that.pos.y)/(height + that.height)) {
          if(pos.y > that.pos.y) {
            vel.y = 9;
            pos.y = that.pos.y + height/2 + that.height/2;
          }
          if(pos.y < that.pos.y) {
            vel.y = -9;
            pos.y = that.pos.y - height/2 - that.height/2;
          }
        }
      }
    }
  }
  public void draw() {
    noStroke();
    fill(255, 0, 0, (hurtTimer%20 < 10) ? 255 : 100);
    rect(pos.x - width/2, pos.y - height/2, width, height);
    fill(214, 17, 17);
    rect(-285, -285, health, 15);
  }
  public void update() {
    vel.mult(0.9);
    pos.add(vel);
    if(keys.get(38)) {
      vel.y -= 0.4;
    }
    if(keys.get(37)) {
      vel.x -= 0.4;
    }
    if(keys.get(40)) {
      vel.y += 0.4;
    }
    if(keys.get(39)) {
      vel.x += 0.4;
    }
    if (hurtTimer > 0) {
      hurtTimer--;
    }
    pos.set(constrain(pos.x, -300 + width/2, 300 - width/2), constrain(pos.y, -300 + height/2, 300 - height/2));
  }
  public void display() {
    runCollisions();
    update();
    draw();
  }
}

Player player;

int[][][][] levels = {
  {
    {
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,1,0,0,0,0,0,0},
      {0,0,0,0,0,0,1,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,2,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,2,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,1,1,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,0,1,0,0,0,0,0},
      {0,0,0,0,0,0,0,1,1,1,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    },
    {
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,1,1,1,2,0,0,0,0,0,0,0},
      {0,0,0,0,1,0,0,1,0,0,0,0,0,0,0},
      {0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,2,1,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
      {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    }
  }
};

void buildLevel(int level) {
  int lvl = floor(random(levels[level].length));
  for(int y = 0;y < levels[level][lvl].length;y++) {
    for(int x = 0;x < levels[level][lvl][y].length;x++) {
      switch(levels[level][lvl][y][x]) {
        case 1: blocks.add(new Block(x * 40 - 280, y * 40 - 280)); break;
        case 2: spikes.add(new Spikes(x * 40 - 280, y * 40 - 280)); break;
        case 3: holes.add(new Hole(x * 40 - 280, y * 40 - 280)); break;
      }
    }
  }
}

void setup() {
  fullScreen();
  player = new Player(-200, -200);
  //There is no real efficient way to load images. :( ;_;
  
  pf1 = loadImage("f1.png");
  pf2 = loadImage("f2.png");
  pf3 = loadImage("f3.png");
  ps1 = loadImage("l1.png");
  ps2 = loadImage("l2.png");
  ps3 = loadImage("l3.png");
  pn1 = loadImage("n1.png");
  pn2 = loadImage("n2.png");
  pn3 = loadImage("n3.png");
  
  spike = loadImage("spike.png");
  
  spike_guy = loadImage("spike_guy.png");
  bb1 = loadImage("bb1.png");
  bb2 = loadImage("bb2.png");
  bb3 = loadImage("bb3.png");
  bb4 = loadImage("bb4.png");
  
  keys.put(37, false);
  keys.put(38, false);
  keys.put(39, false);
  keys.put(40, false);
  buildLevel(0);
  noSmooth();
}

void draw() {
  background(0);
  pushMatrix();
  translate(width/2, height/2);
  scale(0.1);
  scale(0.1);
  int s = min(width/8, height/6);
  scale(s);
  fill(255);
  noStroke();
  rect(-300, -300, 600, 600);
  player.display();
  for(Block that: blocks) {
    that.draw();
  }
  for(Spikes that: spikes) {
    that.draw();
  }
  for(Hole that: holes) {
    that.draw();
  }
  if(player.health <= 0){
    background(255, 0, 0);
    noLoop();
  }
  popMatrix();
  
  fill(0, 0, 0, 100);
  rectMode(CENTER);
  rect(width/2, 50, 100, 50);
  fill(255);
  textAlign(CENTER, CENTER);
  text("Press esc to quit", width/2, 50);
  rectMode(CORNER);
  
}
